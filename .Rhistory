#| label: model0_results - nb model
# Location-only model (Model 0) ----
coefs_0 <- summary(model_0)$coefficients$cond
conf_0 <- confint(model_0)
rownames(conf_0) <- gsub("^cond\\.", "", rownames(conf_0))
conf_0 <- conf_0[rownames(conf_0) %in% rownames(coefs_0), ]
match_0 <- match(rownames(coefs_0), rownames(conf_0))
results_0 <- data.frame(
Term = rownames(coefs_0),
Estimate = coefs_0[, "Estimate"],
StdError = coefs_0[, "Std. Error"],
`2.5%` = conf_0[match_0, "2.5 %"],
`97.5%` = conf_0[match_0, "97.5 %"]
)
colnames(results_0)[which(names(results_0) == "X2.5.")] <- "CI_low"
colnames(results_0)[which(names(results_0) == "X97.5.")] <- "CI_high"
gt(results_0) %>%
tab_header(title = "Location-only model") %>%
fmt_number(columns = everything(), decimals = 3) %>%
cols_label(
Term = "Term",
Estimate = "Estimate",
StdError = "Std. Error",
CI_low = "95% CI (low)",
CI_high = "95% CI (high)"
) %>%
cols_align(align = "center", columns = everything())
#| label: model_fitting2 - model2 - glmmtmb
# location-scale model ----
model2_2 <- glmmTMB(
log(SMI) ~ 1 + RANK + (1|NEST)+(1|WORKYEAR),
dispformula = ~ 1 + RANK,
data = dat,
family = gaussian
)
summary(model2_2)
confint(model2_2)
#| label: model_comparison - model2 - glmmtmb
model.sel(model2_1, model2_2)
#| label: model1_result - model2 - brms
#| echo: false
fit1 <- readRDS(here("Rdata","mod1RED.rds"))
summary(fit1)
#| label: model2_result - model2 - brms
#| echo: false
fit2 <- readRDS(here("Rdata","mod2RED.rds"))
summary(fit2)
#| label: fit1_results - model2 - brms
#| echo: false
results_df1 <- posterior_summary(fit1) %>%
as.data.frame() %>%
tibble::rownames_to_column("term") %>%
filter(grepl("^b_|^sd_|^cor_", term) | term == "sigma") %>%
filter(!term %in% c("b_sigma_Intercept", "b_sigma_RANK2")) %>%
mutate(
Term_Display = case_when(
term == "b_Intercept" ~ "Intercept",
term == "b_RANK2" ~ "Second hatched chick",
term == "sd_NEST__Intercept" ~ "Nest ID ",
term == "sd_WORKYEAR__Intercept" ~ "Year ",
term == "sigma" ~ "Sigma",
TRUE ~ term
),
Order_Rank = case_when(
term == "b_Intercept" ~ 1,
term == "b_RANK2" ~ 2,
term == "sd_NEST__Intercept" ~ 3,
term == "sd_WORKYEAR__Intercept" ~ 4,
term == "sigma" ~ 5,
TRUE ~ 99
),
Submodel = case_when(
Order_Rank %in% 1:2 ~ "Location Model",
Order_Rank %in% 3:4 ~ "Random Effects",
Order_Rank == 5 ~ "Residual Standard Deviation",
TRUE ~ NA_character_
)
) %>%
filter(!is.na(Submodel)) %>%
arrange(Order_Rank) %>%
dplyr::select(
Submodel,
Term = Term_Display,
Estimate = Estimate,
`Std.error` = Est.Error,
`95% CI (low)` = Q2.5,
`95% CI (high)` = Q97.5
) %>%
gt(groupname_col = "Submodel") %>%
tab_header(
title = "Model 1: Posterior Summary"
) %>%
fmt_number(
columns = c(Estimate, `Std.error`, `95% CI (low)`, `95% CI (high)`),
decimals = 3
) %>%
cols_align(
align = "center",
columns = everything()
)
#| label: fit2_results - model2 - brms
#| echo: false
results_df2 <- posterior_summary(fit2) %>%
as.data.frame() %>%
tibble::rownames_to_column("term") %>%
filter(grepl("^b_|^sd_|^cor_", term)) %>%
mutate(
Term_Display = case_when(
term == "b_Intercept" ~ "Intercept",
term == "b_sigma_Intercept" ~ "Intercept (sigma)",
term == "b_RANK2" ~ "Second hatched chick",
term == "b_sigma_RANK2" ~ "Second hatched chick (sigma)",
term == "sd_NEST__Intercept" ~ "Nest ID",
term == "sd_WORKYEAR__Intercept" ~ "Year",
TRUE ~ term
),
Order_Rank = case_when(
term == "b_Intercept" ~ 1,
term == "b_RANK2" ~ 2,
grepl("^b_", term) & !grepl("sigma", term) ~ 3, # Other fixed effects (no sigma)
term == "b_sigma_Intercept" ~ 4,
term == "b_sigma_RANK2" ~ 5,
term == "sd_NEST__Intercept" ~ 6,
term == "sd_WORKYEAR__Intercept" ~ 7,
TRUE ~ 99
),
Submodel = case_when(
Order_Rank %in% 1:3 ~ "Location Submodel",
Order_Rank %in% 4:5 ~ "Scale Submodel",
Order_Rank %in% 6:7 ~ "Random effects",
TRUE ~ NA_character_ # No subtitle for other terms (SDs), though in this filter they might all fall into a category
)
) %>%
arrange(Order_Rank) %>%
dplyr::select(
Submodel, # Include Submodel column
Term = Term_Display,
Estimate = Estimate,
`Std.error` = Est.Error,
`95% CI (low)` = Q2.5,
`95% CI (high)` = Q97.5
) %>%
gt(groupname_col = "Submodel") %>%
tab_header(
title = "Model 2: Posterior Summary"
) %>%
fmt_number(
columns = c(Estimate, `Std.error`, `95% CI (low)`, `95% CI (high)`),
decimals = 3
) %>%
cols_align(
align = "center",
columns = everything()
)
#| echo: false
#| label: model0_results - nb model
# Location-only model (Model 0) ----
coefs_0 <- summary(model_0)$coefficients$cond
conf_0 <- confint(model_0)
rownames(conf_0) <- gsub("^cond\\.", "", rownames(conf_0))
conf_0 <- conf_0[rownames(conf_0) %in% rownames(coefs_0), ]
match_0 <- match(rownames(coefs_0), rownames(conf_0))
results_0 <- data.frame(
Term = rownames(coefs_0),
Estimate = coefs_0[, "Estimate"],
StdError = coefs_0[, "Std. Error"],
`2.5%` = conf_0[match_0, "2.5 %"],
`97.5%` = conf_0[match_0, "97.5 %"]
)
colnames(results_0)[which(names(results_0) == "X2.5.")] <- "CI_low"
colnames(results_0)[which(names(results_0) == "X97.5.")] <- "CI_high"
gt(results_0) %>%
tab_header(title = "Location-only model") %>%
fmt_number(columns = everything(), decimals = 3) %>%
cols_label(
Term = "Term",
Estimate = "Estimate",
StdError = "Std. Error",
CI_low = "95% CI (low)",
CI_high = "95% CI (high)"
) %>%
cols_align(align = "center", columns = everything())
#| label: show_data - beyond_gaussian2
#| fig-width: 8
#| fig-height: 6
dat <- read.csv(here("data","Lundgren_Cougar_Burro_Trophic_Cascade_Trampled_BareGround.csv"))
dat <- dat %>%
dplyr::select(Site, Pool, if_kill, cover) %>%
mutate(Site=as.factor(Site),
if_kill=as.factor(if_kill),
cover=as.numeric(cover)
)
str(dat)
ggplot(dat, aes(x = if_kill, y = cover, fill = if_kill)) +
geom_violin(
aes(fill = if_kill), # Fill violins based on 'if_kill'
color = "#8B8B83", # Outline color for violins
width = 0.8,
alpha = 0.3,
position = position_dodge(width = 0.7)
) +
geom_jitter(
aes(color = if_kill), # Color jittered points based on 'if_kill'
size = 3,
alpha = 0.4,
shape = 1, # Open circles for jittered points
position = position_jitterdodge(dodge.width = 0.5, jitter.width = 0.15)
) +
stat_summary(
fun = mean,
geom = "crossbar",
width = 0.1,
color = "black", # Black crossbar for mean
linewidth = 0.5,
position = position_dodge(width = 0.7)
) +
labs(
title = "Donkey Trampling by Cougar Kill Presence",
x = "Cougar Kill Presence",
y = "Proportion Trampled Bare Ground"
) +
scale_fill_manual(
values = c("burro kills absent" = "cornflowerblue", "burro kills present" = "firebrick")
) +
scale_color_manual( # Add scale_color_manual for jitter points
values = c("burro kills absent" = "cornflowerblue", "burro kills present" = "firebrick")
) +
scale_x_discrete(
labels = c("burro kills absent" = "No", "burro kills present" = "Yes"),
expand = expansion(add = 0.5)
) +
theme_classic(base_size = 16) +
theme(
axis.text = element_text(color = "#6E7B8B", size = 14),
axis.title = element_text(color = "#6E7B8B", size = 14),
legend.position = "none",
axis.text.x = element_text(angle = 0, hjust = 0.5)
)
#| label: show_data - beyond_gaussian2
#| fig-width: 8
#| fig-height: 6
dat <- read.csv(here("data","Lundgren_Cougar_Burro_Trophic_Cascade_Trampled_BareGround.csv"))
dat <- dat %>%
dplyr::select(Site, Pool, if_kill, cover) %>%
mutate(Site=as.factor(Site),
if_kill=as.factor(if_kill),
cover=as.numeric(cover)
)
str(dat)
ggplot(dat, aes(x = if_kill, y = cover, fill = if_kill)) +
geom_violin(
aes(fill = if_kill), # Fill violins based on 'if_kill'
color = "#8B8B83", # Outline color for violins
width = 0.8,
alpha = 0.3,
position = position_dodge(width = 0.7)
) +
geom_jitter(
aes(color = if_kill), # Color jittered points based on 'if_kill'
size = 3,
alpha = 0.4,
shape = 1, # Open circles for jittered points
position = position_jitterdodge(dodge.width = 0.5, jitter.width = 0.15)
) +
stat_summary(
fun = mean,
geom = "crossbar",
width = 0.1,
color = "black", # Black crossbar for mean
linewidth = 0.5,
position = position_dodge(width = 0.7)
) +
labs(
title = "Donkey Trampling by Cougar Kill Presence",
x = "Cougar Kill Presence",
y = "Proportion Trampled Bare Ground"
) +
scale_fill_manual(
values = c("burro kills absent" = "cornflowerblue", "burro kills present" = "firebrick")
) +
scale_color_manual( # Add scale_color_manual for jitter points
values = c("burro kills absent" = "cornflowerblue", "burro kills present" = "firebrick")
) +
scale_x_discrete(
labels = c("burro kills absent" = "No", "burro kills present" = "Yes"),
expand = expansion(add = 0.5)
) +
theme_classic(base_size = 16) +
theme(
axis.text = element_text(color = "#6E7B8B", size = 14),
axis.title = element_text(color = "#6E7B8B", size = 14),
legend.position = "none",
axis.text.x = element_text(angle = 0, hjust = 0.5)
)
#| label: model_fitting1_results - beyond_gaussian2
#| echo: false
fit0 <- readRDS(here("Rdata", "fit0_BETA_Burros.rds"))
summary(fit0)
#| label: model_fitting2_results - beyond_gaussian2
#| echo: false
fit1 <- readRDS(here("Rdata", "fit1_BETA_Burros.rds"))
summary(fit1)
#| label: call new covariable  - eg1
dat<- dat%>%
dplyr::mutate(ST_DATE=scale(ST_DATE,center=T,scale = F))
#| label: model_fitting2 - model2 - glmmtmb  - eg1
model2_2 <- glmmTMB(
log(SMI) ~ 1 + RANK + (1|NEST)+(1|WORKYEAR),
dispformula = ~ 1 + RANK,
data = dat,
family = gaussian
)
#| label: model_fitting2 add new covariable  - eg1
model2_3a <- glmmTMB(
log(SMI) ~ 1 + RANK + ST_DATE + (1|NEST)+(1|WORKYEAR),
dispformula = ~ 1 + RANK,
data = dat,
family = gaussian
)
#| label: model_fitting2 interaction  - eg1
model2_3b<- glmmTMB(
log(SMI) ~ 1 + RANK + ST_DATE + RANK*ST_DATE +(1|NEST)+(1|WORKYEAR),
dispformula = ~ 1 + RANK,
data = dat,
family = gaussian
)
pacman::p_load(
## data manipulation
dplyr, tibble, tidyverse, broom, broom.mixed,
## model fitting
ape, arm, brms, broom.mixed, cmdstanr, emmeans, glmmTMB, MASS, phytools, rstan, TreeTools,
## model checking and evaluation
DHARMa, loo, MuMIn, parallel,
## visualisation
bayesplot, ggplot2, patchwork, tidybayes,
## reporting and utilities
gt, here, kableExtra, knitr
)
packageVersion("brms")
rstan::stan_version()
detach("package:rstan", unload = TRUE)
install.packages("rstan", type = "source")
rstan::stan_version()
pacman::p_load(
## data manipulation
dplyr, tibble, tidyverse, broom, broom.mixed,
## model fitting
ape, arm, brms, broom.mixed, cmdstanr, emmeans, glmmTMB, MASS, phytools, rstan, TreeTools,
## model checking and evaluation
DHARMa, loo, MuMIn, parallel,
## visualisation
bayesplot, ggplot2, patchwork, tidybayes,
## reporting and utilities
gt, here, kableExtra, knitr
)
# load the dataset ----
dat_pref <- read.csv(here("data", "AM_preference.csv"), header = TRUE)
dat_pref <- dat_pref %>%
dplyr::select(-stripe, -full, -subset) %>%
rename(frequency = dot) %>%
mutate(species = phylo, across(c(condition, sex), as.factor))
#| label: model_cmp_brms
max_cores <- 10
num_chains <- 2
threads_per_chain <- floor(max_cores / num_chains)
options(mc.cores = num_chains)
formula <- bf(
frequency ~ 1 + condition + sex + (1 | species) + (1 | id),
shape ~ 1 + condition + sex
)
prior <- default_prior(formula,
data = dat_pref,
family = brmsfamily("com_poisson")
)
system.time(model_nb_brms <- brm(formula,
data = dat_pref,
prior = prior,
chains = num_chains,
iter = 2000,
warmup = 1000,
thin = 1,
threads = threading(threads_per_chain),
family = brmsfamily("com_poisson"),
backend = "cmdstanr"
# control = list(adapt_delta = 0.95)
)
)
summary(model_nb_brms)
model_2 <- glmmTMB(
frequency ~ 1 + condition + sex + (1 | species) + (1 | id),
dispformula = ~ condition + sex,
data = dat_pref,
family = compois(link = "log")
)
summary(model_2)
confint(model_2)
formula <- bf(
frequency ~ 1 + condition + sex + (1 | species) + (1 | id),
shape ~ 1 + condition + sex
)
stancode <- make_stancode(
formula,
data = dat_pref,
family = brmsfamily("com_poisson")
)
cat(stancode)
?family_glmmTMB
fixef(model_nb_brms)
getS3method("family", "compois")
glmmTMB::family_params(compois())
formula <- bf(
frequency ~ 1 + condition + sex + (1 | species) + (1 | id),
shape ~ 1 + condition + sex
)
stancode <- make_stancode(
formula,
data = dat_pref,
family = brmsfamily("com_poisson")
)
cat(stancode)
fixef(model_2)$disp
exp(fixef(model_2)$disp)
?compois
str(compois())
exp(0.09)
system.time(model_CMP_brms <- brm(formula,
data = dat_pref,
prior = prior,
chains = num_chains,
iter = 2000,
warmup = 1000,
thin = 1,
threads = threading(threads_per_chain),
family = brmsfamily("com_poisson"),
backend = "cmdstanr"
control = list(adapt_delta = 0.95, max_treedepth = 15)
system.time(
model_CMP_brms <- brm(formula,
data = dat_pref,
prior = prior,
chains = num_chains,
iter = 2000,
warmup = 1000,
thin = 1,
threads = threading(threads_per_chain),
family = brmsfamily("com_poisson"),
backend = "cmdstanr",
control = list(adapt_delta = 0.95, max_treedepth = 15)
)
)
system.time(
model_CMP_brms <- brm(formula,
data = dat_pref,
prior = prior,
chains = num_chains,
iter = 4000,
warmup = 2000,
thin = 1,
threads = threading(threads_per_chain),
family = brmsfamily("com_poisson"),
backend = "cmdstanr",
control = list(adapt_delta = 0.95, max_treedepth = 15)
)
)
system.time(
model_CMP_brms <- brm(formula,
data = dat_pref,
prior = prior,
chains = num_chains,
iter = 4000,
warmup = 2000,
thin = 1,
threads = threading(threads_per_chain),
family = brmsfamily("com_poisson"),
backend = "cmdstanr",
control = list(adapt_delta = 0.95, max_treedepth = 15)
)
)
quarto::quarto_render(input = ".")
quarto::quarto_render(input = ".")
getwd()
setwd("/Users/pancho/Library/CloudStorage/GoogleDrive-amizuno@ualberta.ca/My Drive/Eco_location-scale_model/Rev_tutorial_qmd")
quarto::quarto_render(input = ".")
model_2 <- readRDS(here("Rdata", "model_CMP_AM.rds"))
summary(model_2)
confint(model_2)
system.time(
model_CMP_brms <- brm(formula,
data = dat_pref,
prior = prior,
chains = num_chains,
iter = 4000,
warmup = 2000,
thin = 1,
threads = threading(threads_per_chain),
family = brmsfamily("com_poisson")
backend = "cmdstanr",
system.time(
model_CMP_brms <- brm(formula,
data = dat_pref,
prior = prior,
chains = num_chains,
iter = 4000,
warmup = 2000,
thin = 1,
threads = threading(threads_per_chain),
family = brmsfamily("com_poisson"),
backend = "cmdstanr",
control = list(adapt_delta = 0.95, max_treedepth = 15)
)
)
quarto::quarto_render(input = ".")
